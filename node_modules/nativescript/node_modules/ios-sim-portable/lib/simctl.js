"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const childProcess = require("./child-process");
const child_process = require("child_process");
const errors = require("./errors");
const _ = require("lodash");
const fs = require("fs");
class Simctl {
    launch(deviceId, appIdentifier, options) {
        return __awaiter(this, void 0, void 0, function* () {
            options = options || {};
            let args = [];
            if (options.waitForDebugger) {
                args.push("-w");
            }
            args = args.concat([deviceId, appIdentifier]);
            if (options.args) {
                let applicationArgs = options.args.trim().split(/\s+/);
                _.each(applicationArgs, (arg) => args.push(arg));
            }
            let result = yield this.spawnAsync("launch", args);
            if (options.waitForDebugger) {
                console.log(`${appIdentifier}: ${result}`);
            }
            return result;
        });
    }
    boot(deviceId) {
        return this.spawnAsync("boot", [deviceId]);
    }
    terminate(deviceId, appIdentifier) {
        return this.spawnAsync("terminate", [deviceId, appIdentifier]);
    }
    install(deviceId, applicationPath) {
        return this.spawnAsync("install", [deviceId, applicationPath]);
    }
    uninstall(deviceId, appIdentifier, opts) {
        return this.spawnAsync("uninstall", [deviceId, appIdentifier], opts);
    }
    notifyPost(deviceId, notification) {
        return this.spawnAsync("notify_post", [deviceId, notification]);
    }
    getAppContainer(deviceId, appIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const appContainerPath = yield this.spawnAsync("get_app_container", [deviceId, appIdentifier]);
                return fs.existsSync(appContainerPath) ? appContainerPath : null;
            }
            catch (e) {
                if (e.message.indexOf("No such file or directory") > -1) {
                    return null;
                }
                throw e;
            }
        });
    }
    getDevices() {
        return __awaiter(this, void 0, void 0, function* () {
            let rawDevices = yield this.spawnAsync("list", ["devices"]);
            let deviceSectionRegex = /-- (iOS) (.+) --(\n    .+)*/mg;
            let match = deviceSectionRegex.exec(rawDevices);
            let matches = [];
            while (match !== null) {
                matches.push(match);
                match = deviceSectionRegex.exec(rawDevices);
            }
            if (matches.length < 1) {
                errors.fail('Could not find device section. ' + match);
            }
            let devices = [];
            for (match of matches) {
                let sdk = match[2];
                for (let line of match[0].split('\n').slice(1)) {
                    let lineRegex = /^\s+(.*?)\s+\(([0-9A-F]{8}(?:-[0-9A-F]{4}){3}-[0-9A-F]{12})\)\s+\((.*?)\)(\s+\((?:.*?)\))?/;
                    let lineMatch = lineRegex.exec(line);
                    if (lineMatch === null) {
                        errors.fail('Could not match line. ' + line);
                    }
                    let available = lineMatch[4];
                    if (available === null || available === undefined) {
                        devices.push({
                            name: lineMatch[1],
                            id: lineMatch[2],
                            fullId: "com.apple.CoreSimulator.SimDeviceType." + lineMatch[1],
                            runtimeVersion: sdk,
                            state: lineMatch[3]
                        });
                    }
                }
            }
            return devices;
        });
    }
    getLog(deviceId, predicate) {
        let predicateArgs = [];
        if (predicate) {
            predicateArgs = ["--predicate", predicate];
        }
        return this.simctlSpawn("spawn", [deviceId, "log", "stream", "--style", "syslog"].concat(predicateArgs));
    }
    spawnAsync(command, args, spawnOpts, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const { canExecuteXcrun, xcodeToolsError } = this.verifyXcodeCommandLineToolsAreInstalled();
            if (!canExecuteXcrun) {
                if (opts.skipError) {
                    return null;
                }
                else {
                    throw xcodeToolsError;
                }
            }
            return childProcess.spawn("xcrun", ["simctl", command].concat(args), spawnOpts, opts);
        });
    }
    verifyXcodeCommandLineToolsAreInstalled() {
        let canExecuteXcrun = false;
        let xcodeToolsError = null;
        try {
            const result = childProcess.execSync("xcode-select -p", { stdio: "pipe" });
            canExecuteXcrun = !!(result && result.toString().trim());
            if (!canExecuteXcrun) {
                xcodeToolsError = new Error("Unable to work with iOS Simulator as Xcode Command Line Tools cannot be found.");
            }
        }
        catch (err) {
            xcodeToolsError = err;
        }
        return { canExecuteXcrun, xcodeToolsError };
    }
    simctlSpawn(command, args, spawnOpts) {
        return child_process.spawn("xcrun", ["simctl", command].concat(args), spawnOpts);
    }
}
exports.Simctl = Simctl;
